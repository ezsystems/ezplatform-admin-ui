{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ezPluginEmbed.js","webpack:///webpack/bootstrap bc66ef9eb2f4155d8f7a","webpack:///./src/bundle/Resources/public/js/alloyeditor/src/plugins/ez-embed.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","58","global","CKEDITOR","plugins","add","requires","init","editor","ezembed","canBeAdded","path","elementPath","contains","widgets","defaults","href","content","view","draggable","template","requiredContent","upcast","element","attributes","insert","instance","dom","createFromHtml","output","wrapper","wrapElement","temp","documentFragment","getDocument","append","initOn","eZ","appendElement","getByElement","ready","fire","focus","edit","on","fireEditorInteraction","syncAlignment","getEzConfigElement","setWidgetContent","cancelEditEvents","initEditMode","contentId","getHref","replace","loadContent","token","document","querySelector","siteaccess","body","JSON","stringify","ViewInput","identifier","public","ContentQuery","Criteria","FacetBuilders","SortClauses","Filter","ContentIdCriterion","limit","offset","request","Request","method","headers","Accept","Content-Type","X-Siteaccess","X-CSRF-Token","mode","credentials","fetch","then","response","json","handleContentLoaded","bind","catch","error","console","log","loadImageVariation","variationHref","_this","imageData","renderEmbedImagePreview","ContentImageVariation","uri","hits","isEmbedImage","$","classList","View","Result","searchHits","searchHit","value","Content","fieldImage","CurrentVersion","Version","Fields","field","find","fieldDefinitionIdentifier","size","getConfig","fieldValue","variations","renderEmbedPreview","Name","loadImagePreviewFromCurrentVersion","currentVersionHref","_this2","data","title","elementNode","createElement","innerHTML","imageUri","setAttribute","cancel","event","align","_setAlignment","_unsetAlignment","type","setAlignment","fireEvent","unsetAlignment","isAligned","setImageType","addClass","isImage","hasClass","setHref","getFirst","next","getNext","remove","node","appendText","moveAfter","insertAfter","moveBefore","insertBefore","setConfig","key","valueElement","getValueElement","setText","getText","undefined","findOne","config","evt","wrapperRegion","getWrapperRegion","target","pageX","left","pageY","top","height","nativeEvent","selectionData","region","scroll","getWindow","getScrollPosition","getClientRect","y","bottom","x","right","direction","SELECTION_TOP_TO_BOTTOM","window"],"mappings":"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","file":"ezPluginEmbed.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ezPluginEmbed\"] = factory();\n\telse\n\t\troot[\"eZ\"] = root[\"eZ\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"] = root[\"eZ\"][\"ezAlloyEditor\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"][\"ezPluginEmbed\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ezPluginEmbed\"] = factory();\n\telse\n\t\troot[\"eZ\"] = root[\"eZ\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"] = root[\"eZ\"][\"ezAlloyEditor\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"][\"ezPluginEmbed\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 58);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 58:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n(function (global) {\n    var IMAGE_TYPE_CLASS = 'ez-embed-type-image';\n    var DATA_ALIGNMENT_ATTR = 'ezalign';\n\n    if (CKEDITOR.plugins.get('ezembed')) {\n        return;\n    }\n\n    /**\n     * CKEditor plugin to configure the widget plugin so that it recognizes the\n     * `div[data-ezelement=\"embed\"]` elements as widget.\n     *\n     * @class ezembed\n     * @namespace CKEDITOR.plugins\n     * @constructor\n     */\n    CKEDITOR.plugins.add('ezembed', {\n        requires: 'widget,ezaddcontent',\n\n        init: function init(editor) {\n            editor.ezembed = {\n                canBeAdded: function canBeAdded() {\n                    var path = editor.elementPath();\n\n                    return !path || path.contains('table', true) === null;\n                }\n            };\n\n            editor.widgets.add('ezembed', {\n                defaults: {\n                    href: \"ezcontent://\",\n                    content: \"home\",\n                    view: \"embed\"\n                },\n                draggable: false,\n                template: '<div data-ezelement=\"ezembed\" data-href=\"{href}\" data-ezview=\"{view}\">{content}</div>',\n                requiredContent: 'div',\n\n                upcast: function upcast(element) {\n                    return element.name === 'div' && element.attributes['data-ezelement'] === 'ezembed';\n                },\n\n                /**\n                 * Insert an `ezembed` widget in the editor. It overrides the\n                 * default implementation to make sure that in the case where an\n                 * embed widget is focused, a new one is added after it.\n                 *\n                 * @method insert\n                 */\n                insert: function insert() {\n                    var element = CKEDITOR.dom.element.createFromHtml(this.template.output(this.defaults)),\n                        wrapper = editor.widgets.wrapElement(element, this.name),\n                        temp = new CKEDITOR.dom.documentFragment(wrapper.getDocument()),\n                        instance;\n\n                    temp.append(wrapper);\n                    editor.widgets.initOn(element, this.name);\n                    editor.eZ.appendElement(wrapper);\n\n                    instance = editor.widgets.getByElement(wrapper);\n                    instance.ready = true;\n                    instance.fire('ready');\n                    instance.focus();\n                },\n\n                /**\n                 * It's not possible to *edit* an embed widget in AlloyEditor,\n                 * so `edit` directly calls `insert` instead. This is needed\n                 * because by default, the CKEditor engine calls this method\n                 * when an embed widget has the focus and the `ezembed` command\n                 * is executed. In AlloyEditor, we want to insert a new widget,\n                 * not to `edit` the focused widget as the editing process is\n                 * provided by the style toolbar.\n                 *\n                 * @method edit\n                 */\n                edit: function edit() {\n                    this.insert();\n                },\n\n                init: function init() {\n                    this.on('focus', this.fireEditorInteraction);\n                    this.syncAlignment();\n                    this.getEzConfigElement();\n                    this.setWidgetContent('');\n                    this.cancelEditEvents();\n\n                    this.initEditMode();\n                },\n\n                /**\n                 * Initializes the edit mode.\n                 *\n                 * @method initEditMode\n                 */\n                initEditMode: function initEditMode() {\n                    var contentId = this.getHref().replace('ezcontent://', '');\n\n                    if (!contentId) {\n                        return;\n                    }\n\n                    this.loadContent(contentId);\n                },\n\n                /**\n                 * Loads the content info.\n                 *\n                 * @method loadContent\n                 * @param {String} contentId The content id\n                 */\n                loadContent: function loadContent(contentId) {\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var body = JSON.stringify({\n                        ViewInput: {\n                            identifier: 'embed-load-content-info-' + contentId,\n                            public: false,\n                            ContentQuery: {\n                                Criteria: {},\n                                FacetBuilders: {},\n                                SortClauses: {},\n                                Filter: { ContentIdCriterion: '' + contentId },\n                                limit: 1,\n                                offset: 0\n                            }\n                        }\n                    });\n                    var request = new Request('/api/ezp/v2/views', {\n                        method: 'POST',\n                        headers: {\n                            'Accept': 'application/vnd.ez.api.View+json; version=1.1',\n                            'Content-Type': 'application/vnd.ez.api.ViewInput+json; version=1.1',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        body: body,\n                        mode: 'cors',\n                        credentials: 'same-origin'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(this.handleContentLoaded.bind(this)).catch(function (error) {\n                        return console.log('error:load:content:info', error);\n                    });\n                },\n\n                /**\n                 * Loads the image variation.\n                 *\n                 * @method loadImageVariation\n                 * @param {String} variationHref The variation href\n                 */\n                loadImageVariation: function loadImageVariation(variationHref) {\n                    var _this = this;\n\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var request = new Request(variationHref, {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/vnd.ez.api.ContentImageVariation+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(function (imageData) {\n                        return _this.renderEmbedImagePreview(imageData.ContentImageVariation.uri);\n                    });\n                },\n\n                /**\n                 * Handles loading the content info.\n                 *\n                 * @method handleContentLoaded\n                 * @param {Object} hits The result of content search\n                 */\n                handleContentLoaded: function handleContentLoaded(hits) {\n                    var isEmbedImage = this.element.$.classList.contains(IMAGE_TYPE_CLASS);\n                    var content = hits.View.Result.searchHits.searchHit[0].value.Content;\n\n                    if (isEmbedImage) {\n                        var fieldImage = content.CurrentVersion.Version.Fields.field.find(function (field) {\n                            return field.fieldDefinitionIdentifier === 'image';\n                        });\n                        var size = this.getConfig('size');\n                        var variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        this.variations = fieldImage.fieldValue.variations;\n\n                        this.loadImageVariation(variationHref);\n                    } else {\n                        this.renderEmbedPreview(content.Name);\n                    }\n                },\n\n                /**\n                 * Loads image preview from current version href\n                 *\n                 * @method loadImagePreviewFromCurrentVersion\n                 * @param {String} currentVersionHref The current version href\n                 */\n                loadImagePreviewFromCurrentVersion: function loadImagePreviewFromCurrentVersion(currentVersionHref) {\n                    var _this2 = this;\n\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var request = new Request(currentVersionHref, {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/vnd.ez.api.Version+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(function (data) {\n                        var fieldImage = data.Version.Fields.field.find(function (field) {\n                            return field.fieldDefinitionIdentifier === 'image';\n                        });\n                        var size = _this2.getConfig('size');\n                        var variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        _this2.variations = fieldImage.fieldValue.variations;\n\n                        _this2.loadImageVariation(variationHref);\n                    });\n                },\n\n                /**\n                 * Renders the embed preview\n                 *\n                 * @method renderEmbedPreview\n                 * @param {String} title The content title\n                 */\n                renderEmbedPreview: function renderEmbedPreview(title) {\n                    var elementNode = document.createElement('p');\n                    var template = '\\n                        <svg class=\"ez-icon\">\\n                            <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"/bundles/ezplatformadminui/img/ez-icons.svg#tag\"></use>\\n                        </svg>\\n                        <span class=\"ez-embed-content__title\">' + title + '</span>\\n                    ';\n\n                    elementNode.classList.add('ez-embed-content');\n                    elementNode.innerHTML = template;\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Renders the embed image preview\n                 *\n                 * @method renderEmbedImagePreview\n                 * @param {String} imageUri The image uri\n                 */\n                renderEmbedImagePreview: function renderEmbedImagePreview(imageUri) {\n                    var elementNode = document.createElement('img');\n\n                    elementNode.setAttribute('src', imageUri);\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Cancels the widget events that trigger the `edit` event as\n                 * an embed widget can not be edited in a *CKEditor way*.\n                 *\n                 * @method cancelEditEvents\n                 */\n                cancelEditEvents: function cancelEditEvents() {\n                    var cancel = function cancel(event) {\n                        return event.cancel();\n                    };\n\n                    this.on('doubleclick', cancel, null, null, 5);\n                    this.on('key', cancel, null, null, 5);\n                },\n\n                /**\n                 * Initializes the alignment on the widget wrapper if the widget\n                 * is aligned.\n                 *\n                 * @method syncAlignment\n                 */\n                syncAlignment: function syncAlignment() {\n                    var align = this.element.data(DATA_ALIGNMENT_ATTR);\n\n                    if (align) {\n                        this._setAlignment(align);\n                    } else {\n                        this._unsetAlignment();\n                    }\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type`. The\n                 * alignment is set by adding the `data-ezalign` attribute\n                 * on the widget wrapper and the widget element.\n                 *\n                 * @method _setAlignment\n                 * @param {String} type\n                 */\n                _setAlignment: function _setAlignment(type) {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, type);\n                    this.element.data(DATA_ALIGNMENT_ATTR, type);\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type` and fires\n                 * the corresponding `editorInteraction` event.\n                 *\n                 * @method setAlignment\n                 * @param {String} type\n                 */\n                setAlignment: function setAlignment(type, fireEvent) {\n                    this._setAlignment(type);\n                    this.fireEditorInteraction('setAlignment' + type);\n                },\n\n                /**\n                 * Removes the alignment of the widget.\n                 *\n                 * @method _unsetAlignment\n                 */\n                _unsetAlignment: function _unsetAlignment() {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, false);\n                    this.element.data(DATA_ALIGNMENT_ATTR, false);\n                },\n\n                /**\n                 * Removes the alignment of the widget and fires the\n                 * corresponding `editorInteraction` event.\n                 *\n                 * @method unsetAlignment\n                 */\n                unsetAlignment: function unsetAlignment() {\n                    this._unsetAlignment();\n                    this.fireEditorInteraction('unsetAlignment');\n                },\n\n                /**\n                 * Checks whether the embed is aligned with `type` alignment.\n                 *\n                 * @method isAligned\n                 * @param {String} type\n                 * @return {Boolean}\n                 */\n                isAligned: function isAligned(type) {\n                    return this.wrapper.data(DATA_ALIGNMENT_ATTR) === type;\n                },\n\n                /**\n                 * Set the embed as an embed representing an image\n                 *\n                 * @method setImageType\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setImageType: function setImageType() {\n                    this.element.addClass(IMAGE_TYPE_CLASS);\n\n                    return this;\n                },\n\n                /**\n                 * Check whether the embed widget represents an image or not.\n                 *\n                 * @method isImage\n                 * @return {Boolean}\n                 */\n                isImage: function isImage() {\n                    return this.element.hasClass(IMAGE_TYPE_CLASS);\n                },\n\n                /**\n                 * Sets the `href` of the embed is URI to the embed content or\n                 * location. (ezcontent://32 for instance).\n                 *\n                 * @method setHref\n                 * @param {String} href\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setHref: function setHref(href) {\n                    this.element.data('href', href);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the `href`of the embed.\n                 *\n                 * @method getHref\n                 * @return {String}\n                 */\n                getHref: function getHref() {\n                    return this.element.data('href');\n                },\n\n                /**\n                 * Sets the widget content. It makes sure the config element is\n                 * not overwritten.\n                 *\n                 * @method setWidgetContent\n                 * @param {String|CKEDITOR.dom.node} content\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setWidgetContent: function setWidgetContent(content) {\n                    var element = this.element.getFirst(),\n                        next = void 0;\n\n                    while (element) {\n                        next = element.getNext();\n                        if (!element.data || !element.data('ezelement')) {\n                            element.remove();\n                        }\n                        element = next;\n                    }\n\n                    if (content instanceof CKEDITOR.dom.node) {\n                        this.element.append(content);\n                    } else {\n                        this.element.appendText(content);\n                    }\n\n                    return this;\n                },\n\n                /**\n                 * Moves the widget after the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveAfter: function moveAfter(element) {\n                    this.wrapper.insertAfter(element);\n                    this.fireEditorInteraction('moveAfter');\n                },\n\n                /**\n                 * Moves the widget before the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveBefore: function moveBefore(element) {\n                    this.wrapper.insertBefore(element);\n                    this.fireEditorInteraction('moveBefore');\n                },\n\n                /**\n                 * Sets a config value under the `key` for the embed.\n                 *\n                 * @method setConfig\n                 * @param {String} key\n                 * @param {String} value\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setConfig: function setConfig(key, value) {\n                    var valueElement = this.getValueElement(key);\n\n                    if (!valueElement) {\n                        valueElement = new CKEDITOR.dom.element('span');\n                        valueElement.data('ezelement', 'ezvalue');\n                        valueElement.data('ezvalue-key', key);\n                        this.getEzConfigElement().append(valueElement);\n                    }\n\n                    valueElement.setText(value);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the config value for the `key` or undefined if the\n                 * config key is not found.\n                 *\n                 * @method getConfig\n                 * @return {String}\n                 */\n                getConfig: function getConfig(key) {\n                    var valueElement = this.getValueElement(key);\n\n                    return valueElement ? valueElement.getText() : undefined;\n                },\n\n                /**\n                 * Returns the Element holding the config under `key`\n                 *\n                 * @method getValueElement\n                 * @param {String} key\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getValueElement: function getValueElement(key) {\n                    return this.element.findOne('[data-ezelement=\"ezvalue\"][data-ezvalue-key=\"' + key + '\"]');\n                },\n\n                /**\n                 * Returns the element used as a container the config values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzConfigElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzConfigElement: function getEzConfigElement() {\n                    var config = this.element.findOne('[data-ezelement=\"ezconfig\"]');\n\n                    if (!config) {\n                        config = new CKEDITOR.dom.element('span');\n                        config.data('ezelement', 'ezconfig');\n                        this.element.append(config, true);\n                    }\n\n                    return config;\n                },\n\n                /**\n                 * Fires the editorInteraction event so that AlloyEditor editor\n                 * UI remains visible and is updated. This method also computes\n                 * `selectionData.region` and the `pageX` and `pageY` properties\n                 * so that the add toolbar is correctly positioned on the\n                 * widget.\n                 *\n                 * @method fireEditorInteraction\n                 * @param {Object|String} evt this initial event info object or\n                 * the event name for which the `editorInteraction` is fired.\n                 */\n                fireEditorInteraction: function fireEditorInteraction(evt) {\n                    var wrapperRegion = this.getWrapperRegion();\n                    var name = evt.name || evt;\n                    var event = {\n                        editor: editor,\n                        target: this.element.$,\n                        name: \"widget\" + name,\n                        pageX: wrapperRegion.left,\n                        pageY: wrapperRegion.top + wrapperRegion.height\n                    };\n\n                    editor.focus();\n                    this.focus();\n\n                    editor.fire('editorInteraction', {\n                        nativeEvent: event,\n                        selectionData: {\n                            element: this.element,\n                            region: wrapperRegion\n                        }\n                    });\n                },\n\n                /**\n                 * Returns the wrapper element region.\n                 *\n                 * @method getWrapperRegion\n                 * @private\n                 * @return {Object}\n                 */\n                getWrapperRegion: function getWrapperRegion() {\n                    var scroll = this.wrapper.getWindow().getScrollPosition();\n                    var region = this.wrapper.getClientRect();\n\n                    region.top += scroll.y;\n                    region.bottom += scroll.y;\n                    region.left += scroll.x;\n                    region.right += scroll.x;\n                    region.direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;\n\n                    return region;\n                }\n            });\n        }\n    });\n})(window);\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// ezPluginEmbed.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 58);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc66ef9eb2f4155d8f7a","(function (global) {\n    const IMAGE_TYPE_CLASS = 'ez-embed-type-image';\n    const DATA_ALIGNMENT_ATTR = 'ezalign';\n\n    if (CKEDITOR.plugins.get('ezembed')) {\n        return;\n    }\n\n    /**\n     * CKEditor plugin to configure the widget plugin so that it recognizes the\n     * `div[data-ezelement=\"embed\"]` elements as widget.\n     *\n     * @class ezembed\n     * @namespace CKEDITOR.plugins\n     * @constructor\n     */\n    CKEDITOR.plugins.add('ezembed', {\n        requires: 'widget,ezaddcontent',\n\n        init: function (editor) {\n            editor.ezembed = {\n                canBeAdded: () => {\n                    const path = editor.elementPath();\n\n                    return !path || path.contains('table', true) === null;\n                }\n            };\n\n            editor.widgets.add('ezembed', {\n                defaults: {\n                    href: \"ezcontent://\",\n                    content: \"home\",\n                    view: \"embed\",\n                },\n                draggable: false,\n                template: '<div data-ezelement=\"ezembed\" data-href=\"{href}\" data-ezview=\"{view}\">{content}</div>',\n                requiredContent: 'div',\n\n                upcast: (element) => {\n                    return (\n                        element.name === 'div' &&\n                        element.attributes['data-ezelement'] === 'ezembed'\n                    );\n                },\n\n                /**\n                 * Insert an `ezembed` widget in the editor. It overrides the\n                 * default implementation to make sure that in the case where an\n                 * embed widget is focused, a new one is added after it.\n                 *\n                 * @method insert\n                 */\n                insert: function () {\n                    var element = CKEDITOR.dom.element.createFromHtml(this.template.output(this.defaults)),\n                        wrapper = editor.widgets.wrapElement(element, this.name),\n                        temp = new CKEDITOR.dom.documentFragment(wrapper.getDocument()),\n                        instance;\n\n                    temp.append(wrapper);\n                    editor.widgets.initOn(element, this.name);\n                    editor.eZ.appendElement(wrapper);\n\n                    instance = editor.widgets.getByElement(wrapper);\n                    instance.ready = true;\n                    instance.fire('ready');\n                    instance.focus();\n                },\n\n                /**\n                 * It's not possible to *edit* an embed widget in AlloyEditor,\n                 * so `edit` directly calls `insert` instead. This is needed\n                 * because by default, the CKEditor engine calls this method\n                 * when an embed widget has the focus and the `ezembed` command\n                 * is executed. In AlloyEditor, we want to insert a new widget,\n                 * not to `edit` the focused widget as the editing process is\n                 * provided by the style toolbar.\n                 *\n                 * @method edit\n                 */\n                edit: function () {\n                    this.insert();\n                },\n\n                init: function () {\n                    this.on('focus', this.fireEditorInteraction);\n                    this.syncAlignment();\n                    this.getEzConfigElement();\n                    this.setWidgetContent('');\n                    this.cancelEditEvents();\n\n                    this.initEditMode();\n                },\n\n                /**\n                 * Initializes the edit mode.\n                 *\n                 * @method initEditMode\n                 */\n                initEditMode: function () {\n                    const contentId = this.getHref().replace('ezcontent://', '');\n\n                    if (!contentId) {\n                        return;\n                    }\n\n                    this.loadContent(contentId);\n                },\n\n                /**\n                 * Loads the content info.\n                 *\n                 * @method loadContent\n                 * @param {String} contentId The content id\n                 */\n                loadContent: function (contentId) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const body = JSON.stringify({\n                        ViewInput: {\n                            identifier: `embed-load-content-info-${contentId}`,\n                            public: false,\n                            ContentQuery: {\n                                Criteria: {},\n                                FacetBuilders: {},\n                                SortClauses: {},\n                                Filter: {ContentIdCriterion: `${contentId}`},\n                                limit: 1,\n                                offset: 0\n                            }\n                        }\n                    });\n                    const request = new Request('/api/ezp/v2/views', {\n                        method: 'POST',\n                        headers: {\n                            'Accept':'application/vnd.ez.api.View+json; version=1.1',\n                            'Content-Type':'application/vnd.ez.api.ViewInput+json; version=1.1',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        body,\n                        mode: 'cors',\n                        credentials: 'same-origin'\n                    });\n\n                    fetch(request)\n                        .then(response => response.json())\n                        .then(this.handleContentLoaded.bind(this))\n                        .catch(error => console.log('error:load:content:info', error));\n                },\n\n                /**\n                 * Loads the image variation.\n                 *\n                 * @method loadImageVariation\n                 * @param {String} variationHref The variation href\n                 */\n                loadImageVariation: function (variationHref) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const request = new Request(variationHref, {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/vnd.ez.api.ContentImageVariation+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token,\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors',\n                    });\n\n                    fetch(request)\n                        .then(response => response.json())\n                        .then(imageData => this.renderEmbedImagePreview(imageData.ContentImageVariation.uri));\n                },\n\n                /**\n                 * Handles loading the content info.\n                 *\n                 * @method handleContentLoaded\n                 * @param {Object} hits The result of content search\n                 */\n                handleContentLoaded: function (hits) {\n                    const isEmbedImage = this.element.$.classList.contains(IMAGE_TYPE_CLASS);\n                    const content = hits.View.Result.searchHits.searchHit[0].value.Content;\n\n                    if (isEmbedImage) {\n                        const fieldImage = content.CurrentVersion.Version.Fields.field.find(field => field.fieldDefinitionIdentifier === 'image');\n                        const size = this.getConfig('size');\n                        const variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        this.variations = fieldImage.fieldValue.variations;\n\n                        this.loadImageVariation(variationHref);\n                    } else {\n                        this.renderEmbedPreview(content.Name);\n                    }\n                },\n\n                /**\n                 * Loads image preview from current version href\n                 *\n                 * @method loadImagePreviewFromCurrentVersion\n                 * @param {String} currentVersionHref The current version href\n                 */\n                loadImagePreviewFromCurrentVersion: function (currentVersionHref) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const request = new Request(currentVersionHref, {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/vnd.ez.api.Version+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token,\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors',\n                    });\n\n                    fetch(request)\n                        .then(response => response.json())\n                        .then(data => {\n                            const fieldImage = data.Version.Fields.field.find(field => field.fieldDefinitionIdentifier === 'image');\n                            const size = this.getConfig('size');\n                            const variationHref = fieldImage.fieldValue.variations[size].href;\n\n                            this.variations = fieldImage.fieldValue.variations;\n\n                            this.loadImageVariation(variationHref);\n                        });\n                },\n\n                /**\n                 * Renders the embed preview\n                 *\n                 * @method renderEmbedPreview\n                 * @param {String} title The content title\n                 */\n                renderEmbedPreview: function (title) {\n                    const elementNode = document.createElement('p');\n                    const template = `\n                        <svg class=\"ez-icon\">\n                            <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"/bundles/ezplatformadminui/img/ez-icons.svg#tag\"></use>\n                        </svg>\n                        <span class=\"ez-embed-content__title\">${title}</span>\n                    `;\n\n                    elementNode.classList.add('ez-embed-content');\n                    elementNode.innerHTML = template;\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Renders the embed image preview\n                 *\n                 * @method renderEmbedImagePreview\n                 * @param {String} imageUri The image uri\n                 */\n                renderEmbedImagePreview: function (imageUri) {\n                    const elementNode = document.createElement('img');\n\n                    elementNode.setAttribute('src', imageUri);\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Cancels the widget events that trigger the `edit` event as\n                 * an embed widget can not be edited in a *CKEditor way*.\n                 *\n                 * @method cancelEditEvents\n                 */\n                cancelEditEvents: function () {\n                    const cancel = (event) => event.cancel();\n\n                    this.on('doubleclick', cancel, null, null, 5);\n                    this.on('key', cancel, null, null, 5);\n                },\n\n                /**\n                 * Initializes the alignment on the widget wrapper if the widget\n                 * is aligned.\n                 *\n                 * @method syncAlignment\n                 */\n                syncAlignment: function () {\n                    const align = this.element.data(DATA_ALIGNMENT_ATTR);\n\n                    if (align) {\n                        this._setAlignment(align);\n                    } else {\n                        this._unsetAlignment();\n                    }\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type`. The\n                 * alignment is set by adding the `data-ezalign` attribute\n                 * on the widget wrapper and the widget element.\n                 *\n                 * @method _setAlignment\n                 * @param {String} type\n                 */\n                _setAlignment: function (type) {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, type);\n                    this.element.data(DATA_ALIGNMENT_ATTR, type);\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type` and fires\n                 * the corresponding `editorInteraction` event.\n                 *\n                 * @method setAlignment\n                 * @param {String} type\n                 */\n                setAlignment: function (type, fireEvent) {\n                    this._setAlignment(type);\n                    this.fireEditorInteraction('setAlignment' + type);\n                },\n\n                /**\n                 * Removes the alignment of the widget.\n                 *\n                 * @method _unsetAlignment\n                 */\n                _unsetAlignment: function () {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, false);\n                    this.element.data(DATA_ALIGNMENT_ATTR, false);\n                },\n\n                /**\n                 * Removes the alignment of the widget and fires the\n                 * corresponding `editorInteraction` event.\n                 *\n                 * @method unsetAlignment\n                 */\n                unsetAlignment: function () {\n                    this._unsetAlignment();\n                    this.fireEditorInteraction('unsetAlignment');\n                },\n\n                /**\n                 * Checks whether the embed is aligned with `type` alignment.\n                 *\n                 * @method isAligned\n                 * @param {String} type\n                 * @return {Boolean}\n                 */\n                isAligned: function (type) {\n                    return this.wrapper.data(DATA_ALIGNMENT_ATTR) === type;\n                },\n\n                /**\n                 * Set the embed as an embed representing an image\n                 *\n                 * @method setImageType\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setImageType: function () {\n                    this.element.addClass(IMAGE_TYPE_CLASS);\n\n                    return this;\n                },\n\n                /**\n                 * Check whether the embed widget represents an image or not.\n                 *\n                 * @method isImage\n                 * @return {Boolean}\n                 */\n                isImage: function () {\n                    return this.element.hasClass(IMAGE_TYPE_CLASS);\n                },\n\n                /**\n                 * Sets the `href` of the embed is URI to the embed content or\n                 * location. (ezcontent://32 for instance).\n                 *\n                 * @method setHref\n                 * @param {String} href\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setHref: function (href) {\n                    this.element.data('href', href);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the `href`of the embed.\n                 *\n                 * @method getHref\n                 * @return {String}\n                 */\n                getHref: function () {\n                    return this.element.data('href');\n                },\n\n                /**\n                 * Sets the widget content. It makes sure the config element is\n                 * not overwritten.\n                 *\n                 * @method setWidgetContent\n                 * @param {String|CKEDITOR.dom.node} content\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setWidgetContent: function (content) {\n                    let element = this.element.getFirst(), next;\n\n                    while (element) {\n                        next = element.getNext();\n                        if (!element.data || !element.data('ezelement')) {\n                            element.remove();\n                        }\n                        element = next;\n                    }\n\n                    if (content instanceof CKEDITOR.dom.node) {\n                        this.element.append(content);\n                    } else {\n                        this.element.appendText(content);\n                    }\n\n                    return this;\n                },\n\n                /**\n                 * Moves the widget after the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveAfter: function (element) {\n                    this.wrapper.insertAfter(element);\n                    this.fireEditorInteraction('moveAfter');\n                },\n\n                /**\n                 * Moves the widget before the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveBefore: function (element) {\n                    this.wrapper.insertBefore(element);\n                    this.fireEditorInteraction('moveBefore');\n                },\n\n                /**\n                 * Sets a config value under the `key` for the embed.\n                 *\n                 * @method setConfig\n                 * @param {String} key\n                 * @param {String} value\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setConfig: function (key, value) {\n                    let valueElement = this.getValueElement(key);\n\n                    if (!valueElement) {\n                        valueElement = new CKEDITOR.dom.element('span');\n                        valueElement.data('ezelement', 'ezvalue');\n                        valueElement.data('ezvalue-key', key);\n                        this.getEzConfigElement().append(valueElement);\n                    }\n\n                    valueElement.setText(value);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the config value for the `key` or undefined if the\n                 * config key is not found.\n                 *\n                 * @method getConfig\n                 * @return {String}\n                 */\n                getConfig: function (key) {\n                    const valueElement = this.getValueElement(key);\n\n                    return valueElement ? valueElement.getText() : undefined;\n                },\n\n                /**\n                 * Returns the Element holding the config under `key`\n                 *\n                 * @method getValueElement\n                 * @param {String} key\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getValueElement: function (key) {\n                    return this.element.findOne('[data-ezelement=\"ezvalue\"][data-ezvalue-key=\"' + key + '\"]');\n                },\n\n                /**\n                 * Returns the element used as a container the config values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzConfigElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzConfigElement: function () {\n                    let config = this.element.findOne('[data-ezelement=\"ezconfig\"]');\n\n                    if (!config) {\n                        config = new CKEDITOR.dom.element('span');\n                        config.data('ezelement', 'ezconfig');\n                        this.element.append(config, true);\n                    }\n\n                    return config;\n                },\n\n                /**\n                 * Fires the editorInteraction event so that AlloyEditor editor\n                 * UI remains visible and is updated. This method also computes\n                 * `selectionData.region` and the `pageX` and `pageY` properties\n                 * so that the add toolbar is correctly positioned on the\n                 * widget.\n                 *\n                 * @method fireEditorInteraction\n                 * @param {Object|String} evt this initial event info object or\n                 * the event name for which the `editorInteraction` is fired.\n                 */\n                fireEditorInteraction: function (evt) {\n                    const wrapperRegion = this.getWrapperRegion();\n                    const name = evt.name || evt;\n                    const event = {\n                            editor: editor,\n                            target: this.element.$,\n                            name: \"widget\" + name,\n                            pageX: wrapperRegion.left,\n                            pageY: wrapperRegion.top + wrapperRegion.height,\n                        };\n\n                    editor.focus();\n                    this.focus();\n\n                    editor.fire('editorInteraction', {\n                        nativeEvent: event,\n                        selectionData: {\n                            element: this.element,\n                            region: wrapperRegion,\n                        },\n                    });\n                },\n\n                /**\n                 * Returns the wrapper element region.\n                 *\n                 * @method getWrapperRegion\n                 * @private\n                 * @return {Object}\n                 */\n                getWrapperRegion: function () {\n                    const scroll = this.wrapper.getWindow().getScrollPosition();\n                    const region = this.wrapper.getClientRect();\n\n                    region.top += scroll.y;\n                    region.bottom += scroll.y;\n                    region.left += scroll.x;\n                    region.right += scroll.x;\n                    region.direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;\n\n                    return region;\n                },\n            });\n        },\n    });\n})(window);\n\n\n\n// WEBPACK FOOTER //\n// ./src/bundle/Resources/public/js/alloyeditor/src/plugins/ez-embed.js"],"sourceRoot":""}