{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ezPluginEmbed.js","webpack:///webpack/bootstrap 8806015d03e379d4d88b","webpack:///./src/bundle/Resources/public/js/alloyeditor/src/plugins/ez-embed.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","60","global","CKEDITOR","plugins","add","requires","init","editor","ezembed","canBeAdded","path","elementPath","contains","widgets","defaults","href","content","view","draggable","template","requiredContent","upcast","element","attributes","insert","instance","dom","createFromHtml","output","wrapper","wrapElement","temp","documentFragment","getDocument","append","initOn","eZ","appendElement","getByElement","ready","fire","focus","edit","on","fireEditorInteraction","syncAlignment","getEzConfigElement","setWidgetContent","cancelEditEvents","initEditMode","contentId","getHref","replace","loadContent","token","document","querySelector","siteaccess","body","JSON","stringify","ViewInput","identifier","public","ContentQuery","Criteria","FacetBuilders","SortClauses","Filter","ContentIdCriterion","limit","offset","request","Request","method","headers","Accept","Content-Type","X-Siteaccess","X-CSRF-Token","mode","credentials","fetch","then","response","json","handleContentLoaded","bind","catch","error","console","log","loadImageVariation","variationHref","_this","imageData","renderEmbedImagePreview","ContentImageVariation","uri","hits","isEmbedImage","$","classList","View","Result","searchHits","searchHit","value","Content","fieldImage","CurrentVersion","Version","Fields","field","find","fieldTypeIdentifier","fieldValue","renderEmbedPreview","Name","size","getConfig","variations","loadImagePreviewFromCurrentVersion","currentVersionHref","contentName","_this2","data","title","elementNode","createElement","innerHTML","imageUri","setAttribute","cancel","event","align","_setAlignment","_unsetAlignment","type","setAlignment","unsetAlignment","isAligned","setImageType","addClass","isImage","hasClass","setHref","getFirst","next","getNext","remove","node","appendText","moveAfter","insertAfter","moveBefore","insertBefore","setConfig","key","valueElement","getValueElement","setText","getText","undefined","findOne","config","getEzLinkElement","link","getEzLinkAttribute","attribute","getAttribute","setEzLinkAttribute","removeEzLinkAttribute","removeAttribute","setLinkEditState","removeLinkEditState","isEditingLink","hasAttribute","evt","wrapperRegion","getWrapperRegion","target","pageX","left","pageY","top","height","nativeEvent","selectionData","region","scroll","getWindow","getScrollPosition","getClientRect","y","bottom","x","right","direction","SELECTION_TOP_TO_BOTTOM","window"],"mappings":"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","file":"ezPluginEmbed.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ezPluginEmbed\"] = factory();\n\telse\n\t\troot[\"eZ\"] = root[\"eZ\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"] = root[\"eZ\"][\"ezAlloyEditor\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"][\"ezPluginEmbed\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ezPluginEmbed\"] = factory();\n\telse\n\t\troot[\"eZ\"] = root[\"eZ\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"] = root[\"eZ\"][\"ezAlloyEditor\"] || {}, root[\"eZ\"][\"ezAlloyEditor\"][\"ezPluginEmbed\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 60);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 60:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n(function (global) {\n    var IMAGE_TYPE_CLASS = 'ez-embed-type-image';\n    var EDIT_LINK_STATE_ATTR = 'data-ez-is-in-edit-link';\n    var DATA_ALIGNMENT_ATTR = 'ezalign';\n\n    if (CKEDITOR.plugins.get('ezembed')) {\n        return;\n    }\n\n    /**\n     * CKEditor plugin to configure the widget plugin so that it recognizes the\n     * `div[data-ezelement=\"embed\"]` elements as widget.\n     *\n     * @class ezembed\n     * @namespace CKEDITOR.plugins\n     * @constructor\n     */\n    CKEDITOR.plugins.add('ezembed', {\n        requires: 'widget,ezaddcontent',\n\n        init: function init(editor) {\n            editor.ezembed = {\n                canBeAdded: function canBeAdded() {\n                    var path = editor.elementPath();\n\n                    return !path || path.contains('table', true) === null;\n                }\n            };\n\n            editor.widgets.add('ezembed', {\n                defaults: {\n                    href: 'ezcontent://',\n                    content: 'home',\n                    view: 'embed'\n                },\n                draggable: false,\n                template: '<div data-ezelement=\"ezembed\" data-href=\"{href}\" data-ezview=\"{view}\">{content}</div>',\n                requiredContent: 'div',\n\n                upcast: function upcast(element) {\n                    return element.name === 'div' && element.attributes['data-ezelement'] === 'ezembed';\n                },\n\n                /**\n                 * Insert an `ezembed` widget in the editor. It overrides the\n                 * default implementation to make sure that in the case where an\n                 * embed widget is focused, a new one is added after it.\n                 *\n                 * @method insert\n                 */\n                insert: function insert() {\n                    var element = CKEDITOR.dom.element.createFromHtml(this.template.output(this.defaults)),\n                        wrapper = editor.widgets.wrapElement(element, this.name),\n                        temp = new CKEDITOR.dom.documentFragment(wrapper.getDocument()),\n                        instance;\n\n                    temp.append(wrapper);\n                    editor.widgets.initOn(element, this.name);\n                    editor.eZ.appendElement(wrapper);\n\n                    instance = editor.widgets.getByElement(wrapper);\n                    instance.ready = true;\n                    instance.fire('ready');\n                    instance.focus();\n                },\n\n                /**\n                 * It's not possible to *edit* an embed widget in AlloyEditor,\n                 * so `edit` directly calls `insert` instead. This is needed\n                 * because by default, the CKEditor engine calls this method\n                 * when an embed widget has the focus and the `ezembed` command\n                 * is executed. In AlloyEditor, we want to insert a new widget,\n                 * not to `edit` the focused widget as the editing process is\n                 * provided by the style toolbar.\n                 *\n                 * @method edit\n                 */\n                edit: function edit() {\n                    this.insert();\n                },\n\n                init: function init() {\n                    this.on('focus', this.fireEditorInteraction);\n                    this.syncAlignment();\n                    this.getEzConfigElement();\n                    this.setWidgetContent('');\n                    this.cancelEditEvents();\n\n                    this.initEditMode();\n                },\n\n                /**\n                 * Initializes the edit mode.\n                 *\n                 * @method initEditMode\n                 */\n                initEditMode: function initEditMode() {\n                    var contentId = this.getHref().replace('ezcontent://', '');\n\n                    if (!contentId) {\n                        return;\n                    }\n\n                    this.loadContent(contentId);\n                },\n\n                /**\n                 * Loads the content info.\n                 *\n                 * @method loadContent\n                 * @param {String} contentId The content id\n                 */\n                loadContent: function loadContent(contentId) {\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var body = JSON.stringify({\n                        ViewInput: {\n                            identifier: 'embed-load-content-info-' + contentId,\n                            public: false,\n                            ContentQuery: {\n                                Criteria: {},\n                                FacetBuilders: {},\n                                SortClauses: {},\n                                Filter: { ContentIdCriterion: '' + contentId },\n                                limit: 1,\n                                offset: 0\n                            }\n                        }\n                    });\n                    var request = new Request('/api/ezp/v2/views', {\n                        method: 'POST',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.View+json; version=1.1',\n                            'Content-Type': 'application/vnd.ez.api.ViewInput+json; version=1.1',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        body: body,\n                        mode: 'cors',\n                        credentials: 'same-origin'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(this.handleContentLoaded.bind(this)).catch(function (error) {\n                        return console.log('error:load:content:info', error);\n                    });\n                },\n\n                /**\n                 * Loads the image variation.\n                 *\n                 * @method loadImageVariation\n                 * @param {String} variationHref The variation href\n                 */\n                loadImageVariation: function loadImageVariation(variationHref) {\n                    var _this = this;\n\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var request = new Request(variationHref, {\n                        method: 'GET',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.ContentImageVariation+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(function (imageData) {\n                        return _this.renderEmbedImagePreview(imageData.ContentImageVariation.uri);\n                    });\n                },\n\n                /**\n                 * Handles loading the content info.\n                 *\n                 * @method handleContentLoaded\n                 * @param {Object} hits The result of content search\n                 */\n                handleContentLoaded: function handleContentLoaded(hits) {\n                    var isEmbedImage = this.element.$.classList.contains(IMAGE_TYPE_CLASS);\n                    var content = hits.View.Result.searchHits.searchHit[0].value.Content;\n\n                    if (isEmbedImage) {\n                        var fieldImage = content.CurrentVersion.Version.Fields.field.find(function (field) {\n                            return field.fieldTypeIdentifier === 'ezimage';\n                        });\n\n                        if (!fieldImage || !fieldImage.fieldValue) {\n                            this.renderEmbedPreview(content.Name);\n\n                            return;\n                        }\n\n                        var size = this.getConfig('size');\n                        var variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        this.variations = fieldImage.fieldValue.variations;\n\n                        this.loadImageVariation(variationHref);\n                    } else {\n                        this.renderEmbedPreview(content.Name);\n                    }\n                },\n\n                /**\n                 * Loads image preview from current version href\n                 *\n                 * @method loadImagePreviewFromCurrentVersion\n                 * @param {String} currentVersionHref The current version href\n                 * @param {String} contnetName The content name\n                 */\n                loadImagePreviewFromCurrentVersion: function loadImagePreviewFromCurrentVersion(currentVersionHref, contentName) {\n                    var _this2 = this;\n\n                    var token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    var siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    var request = new Request(currentVersionHref, {\n                        method: 'GET',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.Version+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors'\n                    });\n\n                    fetch(request).then(function (response) {\n                        return response.json();\n                    }).then(function (data) {\n                        var fieldImage = data.Version.Fields.field.find(function (field) {\n                            return field.fieldTypeIdentifier === 'ezimage';\n                        });\n\n                        if (!fieldImage || !fieldImage.fieldValue) {\n                            contentName = contentName ? contentName : '';\n\n                            _this2.renderEmbedPreview(contentName);\n\n                            return;\n                        }\n\n                        var size = _this2.getConfig('size');\n                        var variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        _this2.variations = fieldImage.fieldValue.variations;\n\n                        _this2.loadImageVariation(variationHref);\n                    });\n                },\n\n                /**\n                 * Renders the embed preview\n                 *\n                 * @method renderEmbedPreview\n                 * @param {String} title The content title\n                 */\n                renderEmbedPreview: function renderEmbedPreview(title) {\n                    var elementNode = document.createElement('p');\n                    var template = '\\n                        <svg class=\"ez-icon\">\\n                            <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"/bundles/ezplatformadminui/img/ez-icons.svg#tag\"></use>\\n                        </svg>\\n                        <span class=\"ez-embed-content__title\">' + title + '</span>\\n                    ';\n\n                    elementNode.classList.add('ez-embed-content');\n                    elementNode.innerHTML = template;\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Renders the embed image preview\n                 *\n                 * @method renderEmbedImagePreview\n                 * @param {String} imageUri The image uri\n                 */\n                renderEmbedImagePreview: function renderEmbedImagePreview(imageUri) {\n                    var elementNode = document.createElement('img');\n\n                    elementNode.setAttribute('src', imageUri);\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Cancels the widget events that trigger the `edit` event as\n                 * an embed widget can not be edited in a *CKEditor way*.\n                 *\n                 * @method cancelEditEvents\n                 */\n                cancelEditEvents: function cancelEditEvents() {\n                    var cancel = function cancel(event) {\n                        return event.cancel();\n                    };\n\n                    this.on('doubleclick', cancel, null, null, 5);\n                    this.on('key', cancel, null, null, 5);\n                },\n\n                /**\n                 * Initializes the alignment on the widget wrapper if the widget\n                 * is aligned.\n                 *\n                 * @method syncAlignment\n                 */\n                syncAlignment: function syncAlignment() {\n                    var align = this.element.data(DATA_ALIGNMENT_ATTR);\n\n                    if (align) {\n                        this._setAlignment(align);\n                    } else {\n                        this._unsetAlignment();\n                    }\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type`. The\n                 * alignment is set by adding the `data-ezalign` attribute\n                 * on the widget wrapper and the widget element.\n                 *\n                 * @method _setAlignment\n                 * @param {String} type\n                 */\n                _setAlignment: function _setAlignment(type) {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, type);\n                    this.element.data(DATA_ALIGNMENT_ATTR, type);\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type` and fires\n                 * the corresponding `editorInteraction` event.\n                 *\n                 * @method setAlignment\n                 * @param {String} type\n                 */\n                setAlignment: function setAlignment(type) {\n                    this._setAlignment(type);\n                    this.fireEditorInteraction('setAlignment' + type);\n                },\n\n                /**\n                 * Removes the alignment of the widget.\n                 *\n                 * @method _unsetAlignment\n                 */\n                _unsetAlignment: function _unsetAlignment() {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, false);\n                    this.element.data(DATA_ALIGNMENT_ATTR, false);\n                },\n\n                /**\n                 * Removes the alignment of the widget and fires the\n                 * corresponding `editorInteraction` event.\n                 *\n                 * @method unsetAlignment\n                 */\n                unsetAlignment: function unsetAlignment() {\n                    this._unsetAlignment();\n                    this.fireEditorInteraction('unsetAlignment');\n                },\n\n                /**\n                 * Checks whether the embed is aligned with `type` alignment.\n                 *\n                 * @method isAligned\n                 * @param {String} type\n                 * @return {Boolean}\n                 */\n                isAligned: function isAligned(type) {\n                    return this.wrapper.data(DATA_ALIGNMENT_ATTR) === type;\n                },\n\n                /**\n                 * Set the embed as an embed representing an image\n                 *\n                 * @method setImageType\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setImageType: function setImageType() {\n                    this.element.addClass(IMAGE_TYPE_CLASS);\n\n                    return this;\n                },\n\n                /**\n                 * Check whether the embed widget represents an image or not.\n                 *\n                 * @method isImage\n                 * @return {Boolean}\n                 */\n                isImage: function isImage() {\n                    return this.element.hasClass(IMAGE_TYPE_CLASS);\n                },\n\n                /**\n                 * Sets the `href` of the embed is URI to the embed content or\n                 * location. (ezcontent://32 for instance).\n                 *\n                 * @method setHref\n                 * @param {String} href\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setHref: function setHref(href) {\n                    this.element.data('href', href);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the `href`of the embed.\n                 *\n                 * @method getHref\n                 * @return {String}\n                 */\n                getHref: function getHref() {\n                    return this.element.data('href');\n                },\n\n                /**\n                 * Sets the widget content. It makes sure the config element is\n                 * not overwritten.\n                 *\n                 * @method setWidgetContent\n                 * @param {String|CKEDITOR.dom.node} content\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setWidgetContent: function setWidgetContent(content) {\n                    var element = this.element.getFirst(),\n                        next = void 0;\n\n                    while (element) {\n                        next = element.getNext();\n                        if (!element.data || !element.data('ezelement')) {\n                            element.remove();\n                        }\n                        element = next;\n                    }\n\n                    if (content instanceof CKEDITOR.dom.node) {\n                        this.element.append(content);\n                    } else {\n                        this.element.appendText(content);\n                    }\n\n                    return this;\n                },\n\n                /**\n                 * Moves the widget after the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveAfter: function moveAfter(element) {\n                    this.wrapper.insertAfter(element);\n                    this.fireEditorInteraction('moveAfter');\n                },\n\n                /**\n                 * Moves the widget before the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveBefore: function moveBefore(element) {\n                    this.wrapper.insertBefore(element);\n                    this.fireEditorInteraction('moveBefore');\n                },\n\n                /**\n                 * Sets a config value under the `key` for the embed.\n                 *\n                 * @method setConfig\n                 * @param {String} key\n                 * @param {String} value\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setConfig: function setConfig(key, value) {\n                    var valueElement = this.getValueElement(key);\n\n                    if (!valueElement) {\n                        valueElement = new CKEDITOR.dom.element('span');\n                        valueElement.data('ezelement', 'ezvalue');\n                        valueElement.data('ezvalue-key', key);\n                        this.getEzConfigElement().append(valueElement);\n                    }\n\n                    valueElement.setText(value);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the config value for the `key` or undefined if the\n                 * config key is not found.\n                 *\n                 * @method getConfig\n                 * @return {String}\n                 */\n                getConfig: function getConfig(key) {\n                    var valueElement = this.getValueElement(key);\n\n                    return valueElement ? valueElement.getText() : undefined;\n                },\n\n                /**\n                 * Returns the Element holding the config under `key`\n                 *\n                 * @method getValueElement\n                 * @param {String} key\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getValueElement: function getValueElement(key) {\n                    return this.element.findOne('[data-ezelement=\"ezvalue\"][data-ezvalue-key=\"' + key + '\"]');\n                },\n\n                /**\n                 * Returns the element used as a container the config values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzConfigElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzConfigElement: function getEzConfigElement() {\n                    var config = this.element.findOne('[data-ezelement=\"ezconfig\"]');\n\n                    if (!config) {\n                        config = new CKEDITOR.dom.element('span');\n                        config.data('ezelement', 'ezconfig');\n                        this.element.append(config, true);\n                    }\n\n                    return config;\n                },\n\n                /**\n                 * Returns the element used as a container the link values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzLinkElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzLinkElement: function getEzLinkElement() {\n                    var link = this.element.findOne('[data-ezelement=\"ezlink\"]');\n\n                    if (!link) {\n                        link = new CKEDITOR.dom.element('a');\n                        link.$.innerHTML = ' ';\n                        link.setAttribute('data-ezelement', 'ezlink');\n                        link.setAttribute('data-ez-temporary-link', true);\n                        this.element.append(link);\n                    }\n\n                    return link;\n                },\n\n                /**\n                 * Gets the link attribute\n                 *\n                 * @method getEzLinkAttribute\n                 * @param {String} attribute\n                 * @return {String}\n                 */\n                getEzLinkAttribute: function getEzLinkAttribute(attribute) {\n                    var link = this.getEzLinkElement();\n\n                    return link.getAttribute(attribute);\n                },\n\n                /**\n                 * Sets the link attribute\n                 *\n                 * @method getEzLinkAttribute\n                 * @param {String} attribute\n                 * @param {String} value\n                 */\n                setEzLinkAttribute: function setEzLinkAttribute(attribute, value) {\n                    var link = this.getEzLinkElement();\n\n                    link.setAttribute(attribute, value);\n                },\n\n                /**\n                 * Removes the link attribute\n                 *\n                 * @method removeEzLinkAttribute\n                 * @param {String} attribute\n                 */\n                removeEzLinkAttribute: function removeEzLinkAttribute(attribute) {\n                    var link = this.getEzLinkElement();\n\n                    link.removeAttribute(attribute);\n                },\n\n                /**\n                 * Sets the link edit state\n                 *\n                 * @method setLinkEditState\n                 */\n                setLinkEditState: function setLinkEditState() {\n                    this.element.setAttribute(EDIT_LINK_STATE_ATTR, true);\n                },\n\n                /**\n                 * Removes the link edit state\n                 *\n                 * @method removeLinkEditState\n                 */\n                removeLinkEditState: function removeLinkEditState() {\n                    this.element.removeAttribute(EDIT_LINK_STATE_ATTR);\n                },\n\n                /**\n                 * Checks if widget is in link edit state\n                 *\n                 * @method isEditingLink\n                 * @return {Boolean}\n                 */\n                isEditingLink: function isEditingLink() {\n                    return this.element.hasAttribute(EDIT_LINK_STATE_ATTR);\n                },\n\n                /**\n                 * Fires the editorInteraction event so that AlloyEditor editor\n                 * UI remains visible and is updated. This method also computes\n                 * `selectionData.region` and the `pageX` and `pageY` properties\n                 * so that the add toolbar is correctly positioned on the\n                 * widget.\n                 *\n                 * @method fireEditorInteraction\n                 * @param {Object|String} evt this initial event info object or\n                 * the event name for which the `editorInteraction` is fired.\n                 */\n                fireEditorInteraction: function fireEditorInteraction(evt) {\n                    var wrapperRegion = this.getWrapperRegion();\n                    var name = evt.name || evt;\n                    var event = {\n                        editor: editor,\n                        target: this.element.$,\n                        name: 'widget' + name,\n                        pageX: wrapperRegion.left,\n                        pageY: wrapperRegion.top + wrapperRegion.height\n                    };\n\n                    editor.focus();\n                    this.focus();\n\n                    editor.fire('editorInteraction', {\n                        nativeEvent: event,\n                        selectionData: {\n                            element: this.element,\n                            region: wrapperRegion\n                        }\n                    });\n                },\n\n                /**\n                 * Returns the wrapper element region.\n                 *\n                 * @method getWrapperRegion\n                 * @private\n                 * @return {Object}\n                 */\n                getWrapperRegion: function getWrapperRegion() {\n                    var scroll = this.wrapper.getWindow().getScrollPosition();\n                    var region = this.wrapper.getClientRect();\n\n                    region.top += scroll.y;\n                    region.bottom += scroll.y;\n                    region.left += scroll.x;\n                    region.right += scroll.x;\n                    region.direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;\n\n                    return region;\n                }\n            });\n        }\n    });\n})(window);\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// ezPluginEmbed.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 60);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8806015d03e379d4d88b","(function(global) {\n    const IMAGE_TYPE_CLASS = 'ez-embed-type-image';\n    const EDIT_LINK_STATE_ATTR = 'data-ez-is-in-edit-link';\n    const DATA_ALIGNMENT_ATTR = 'ezalign';\n\n    if (CKEDITOR.plugins.get('ezembed')) {\n        return;\n    }\n\n    /**\n     * CKEditor plugin to configure the widget plugin so that it recognizes the\n     * `div[data-ezelement=\"embed\"]` elements as widget.\n     *\n     * @class ezembed\n     * @namespace CKEDITOR.plugins\n     * @constructor\n     */\n    CKEDITOR.plugins.add('ezembed', {\n        requires: 'widget,ezaddcontent',\n\n        init: function(editor) {\n            editor.ezembed = {\n                canBeAdded: () => {\n                    const path = editor.elementPath();\n\n                    return !path || path.contains('table', true) === null;\n                },\n            };\n\n            editor.widgets.add('ezembed', {\n                defaults: {\n                    href: 'ezcontent://',\n                    content: 'home',\n                    view: 'embed',\n                },\n                draggable: false,\n                template: '<div data-ezelement=\"ezembed\" data-href=\"{href}\" data-ezview=\"{view}\">{content}</div>',\n                requiredContent: 'div',\n\n                upcast: (element) => {\n                    return element.name === 'div' && element.attributes['data-ezelement'] === 'ezembed';\n                },\n\n                /**\n                 * Insert an `ezembed` widget in the editor. It overrides the\n                 * default implementation to make sure that in the case where an\n                 * embed widget is focused, a new one is added after it.\n                 *\n                 * @method insert\n                 */\n                insert: function() {\n                    var element = CKEDITOR.dom.element.createFromHtml(this.template.output(this.defaults)),\n                        wrapper = editor.widgets.wrapElement(element, this.name),\n                        temp = new CKEDITOR.dom.documentFragment(wrapper.getDocument()),\n                        instance;\n\n                    temp.append(wrapper);\n                    editor.widgets.initOn(element, this.name);\n                    editor.eZ.appendElement(wrapper);\n\n                    instance = editor.widgets.getByElement(wrapper);\n                    instance.ready = true;\n                    instance.fire('ready');\n                    instance.focus();\n                },\n\n                /**\n                 * It's not possible to *edit* an embed widget in AlloyEditor,\n                 * so `edit` directly calls `insert` instead. This is needed\n                 * because by default, the CKEditor engine calls this method\n                 * when an embed widget has the focus and the `ezembed` command\n                 * is executed. In AlloyEditor, we want to insert a new widget,\n                 * not to `edit` the focused widget as the editing process is\n                 * provided by the style toolbar.\n                 *\n                 * @method edit\n                 */\n                edit: function() {\n                    this.insert();\n                },\n\n                init: function() {\n                    this.on('focus', this.fireEditorInteraction);\n                    this.syncAlignment();\n                    this.getEzConfigElement();\n                    this.setWidgetContent('');\n                    this.cancelEditEvents();\n\n                    this.initEditMode();\n                },\n\n                /**\n                 * Initializes the edit mode.\n                 *\n                 * @method initEditMode\n                 */\n                initEditMode: function() {\n                    const contentId = this.getHref().replace('ezcontent://', '');\n\n                    if (!contentId) {\n                        return;\n                    }\n\n                    this.loadContent(contentId);\n                },\n\n                /**\n                 * Loads the content info.\n                 *\n                 * @method loadContent\n                 * @param {String} contentId The content id\n                 */\n                loadContent: function(contentId) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const body = JSON.stringify({\n                        ViewInput: {\n                            identifier: `embed-load-content-info-${contentId}`,\n                            public: false,\n                            ContentQuery: {\n                                Criteria: {},\n                                FacetBuilders: {},\n                                SortClauses: {},\n                                Filter: { ContentIdCriterion: `${contentId}` },\n                                limit: 1,\n                                offset: 0,\n                            },\n                        },\n                    });\n                    const request = new Request('/api/ezp/v2/views', {\n                        method: 'POST',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.View+json; version=1.1',\n                            'Content-Type': 'application/vnd.ez.api.ViewInput+json; version=1.1',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token,\n                        },\n                        body,\n                        mode: 'cors',\n                        credentials: 'same-origin',\n                    });\n\n                    fetch(request)\n                        .then((response) => response.json())\n                        .then(this.handleContentLoaded.bind(this))\n                        .catch((error) => console.log('error:load:content:info', error));\n                },\n\n                /**\n                 * Loads the image variation.\n                 *\n                 * @method loadImageVariation\n                 * @param {String} variationHref The variation href\n                 */\n                loadImageVariation: function(variationHref) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const request = new Request(variationHref, {\n                        method: 'GET',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.ContentImageVariation+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token,\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors',\n                    });\n\n                    fetch(request)\n                        .then((response) => response.json())\n                        .then((imageData) => this.renderEmbedImagePreview(imageData.ContentImageVariation.uri));\n                },\n\n                /**\n                 * Handles loading the content info.\n                 *\n                 * @method handleContentLoaded\n                 * @param {Object} hits The result of content search\n                 */\n                handleContentLoaded: function(hits) {\n                    const isEmbedImage = this.element.$.classList.contains(IMAGE_TYPE_CLASS);\n                    const content = hits.View.Result.searchHits.searchHit[0].value.Content;\n\n                    if (isEmbedImage) {\n                        const fieldImage = content.CurrentVersion.Version.Fields.field.find(\n                            (field) => field.fieldTypeIdentifier === 'ezimage'\n                        );\n\n                        if (!fieldImage || !fieldImage.fieldValue) {\n                            this.renderEmbedPreview(content.Name);\n\n                            return;\n                        }\n\n                        const size = this.getConfig('size');\n                        const variationHref = fieldImage.fieldValue.variations[size].href;\n\n                        this.variations = fieldImage.fieldValue.variations;\n\n                        this.loadImageVariation(variationHref);\n                    } else {\n                        this.renderEmbedPreview(content.Name);\n                    }\n                },\n\n                /**\n                 * Loads image preview from current version href\n                 *\n                 * @method loadImagePreviewFromCurrentVersion\n                 * @param {String} currentVersionHref The current version href\n                 * @param {String} contnetName The content name\n                 */\n                loadImagePreviewFromCurrentVersion: function(currentVersionHref, contentName) {\n                    const token = document.querySelector('meta[name=\"CSRF-Token\"]').content;\n                    const siteaccess = document.querySelector('meta[name=\"SiteAccess\"]').content;\n                    const request = new Request(currentVersionHref, {\n                        method: 'GET',\n                        headers: {\n                            Accept: 'application/vnd.ez.api.Version+json',\n                            'X-Siteaccess': siteaccess,\n                            'X-CSRF-Token': token,\n                        },\n                        credentials: 'same-origin',\n                        mode: 'cors',\n                    });\n\n                    fetch(request)\n                        .then((response) => response.json())\n                        .then((data) => {\n                            const fieldImage = data.Version.Fields.field.find((field) => field.fieldTypeIdentifier === 'ezimage');\n\n                            if (!fieldImage || !fieldImage.fieldValue) {\n                                contentName = contentName ? contentName : '';\n\n                                this.renderEmbedPreview(contentName);\n\n                                return;\n                            }\n\n                            const size = this.getConfig('size');\n                            const variationHref = fieldImage.fieldValue.variations[size].href;\n\n                            this.variations = fieldImage.fieldValue.variations;\n\n                            this.loadImageVariation(variationHref);\n                        });\n                },\n\n                /**\n                 * Renders the embed preview\n                 *\n                 * @method renderEmbedPreview\n                 * @param {String} title The content title\n                 */\n                renderEmbedPreview: function(title) {\n                    const elementNode = document.createElement('p');\n                    const template = `\n                        <svg class=\"ez-icon\">\n                            <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"/bundles/ezplatformadminui/img/ez-icons.svg#tag\"></use>\n                        </svg>\n                        <span class=\"ez-embed-content__title\">${title}</span>\n                    `;\n\n                    elementNode.classList.add('ez-embed-content');\n                    elementNode.innerHTML = template;\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Renders the embed image preview\n                 *\n                 * @method renderEmbedImagePreview\n                 * @param {String} imageUri The image uri\n                 */\n                renderEmbedImagePreview: function(imageUri) {\n                    const elementNode = document.createElement('img');\n\n                    elementNode.setAttribute('src', imageUri);\n\n                    this.setWidgetContent(elementNode);\n                },\n\n                /**\n                 * Cancels the widget events that trigger the `edit` event as\n                 * an embed widget can not be edited in a *CKEditor way*.\n                 *\n                 * @method cancelEditEvents\n                 */\n                cancelEditEvents: function() {\n                    const cancel = (event) => event.cancel();\n\n                    this.on('doubleclick', cancel, null, null, 5);\n                    this.on('key', cancel, null, null, 5);\n                },\n\n                /**\n                 * Initializes the alignment on the widget wrapper if the widget\n                 * is aligned.\n                 *\n                 * @method syncAlignment\n                 */\n                syncAlignment: function() {\n                    const align = this.element.data(DATA_ALIGNMENT_ATTR);\n\n                    if (align) {\n                        this._setAlignment(align);\n                    } else {\n                        this._unsetAlignment();\n                    }\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type`. The\n                 * alignment is set by adding the `data-ezalign` attribute\n                 * on the widget wrapper and the widget element.\n                 *\n                 * @method _setAlignment\n                 * @param {String} type\n                 */\n                _setAlignment: function(type) {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, type);\n                    this.element.data(DATA_ALIGNMENT_ATTR, type);\n                },\n\n                /**\n                 * Sets the alignment of the embed widget to `type` and fires\n                 * the corresponding `editorInteraction` event.\n                 *\n                 * @method setAlignment\n                 * @param {String} type\n                 */\n                setAlignment: function(type) {\n                    this._setAlignment(type);\n                    this.fireEditorInteraction('setAlignment' + type);\n                },\n\n                /**\n                 * Removes the alignment of the widget.\n                 *\n                 * @method _unsetAlignment\n                 */\n                _unsetAlignment: function() {\n                    this.wrapper.data(DATA_ALIGNMENT_ATTR, false);\n                    this.element.data(DATA_ALIGNMENT_ATTR, false);\n                },\n\n                /**\n                 * Removes the alignment of the widget and fires the\n                 * corresponding `editorInteraction` event.\n                 *\n                 * @method unsetAlignment\n                 */\n                unsetAlignment: function() {\n                    this._unsetAlignment();\n                    this.fireEditorInteraction('unsetAlignment');\n                },\n\n                /**\n                 * Checks whether the embed is aligned with `type` alignment.\n                 *\n                 * @method isAligned\n                 * @param {String} type\n                 * @return {Boolean}\n                 */\n                isAligned: function(type) {\n                    return this.wrapper.data(DATA_ALIGNMENT_ATTR) === type;\n                },\n\n                /**\n                 * Set the embed as an embed representing an image\n                 *\n                 * @method setImageType\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setImageType: function() {\n                    this.element.addClass(IMAGE_TYPE_CLASS);\n\n                    return this;\n                },\n\n                /**\n                 * Check whether the embed widget represents an image or not.\n                 *\n                 * @method isImage\n                 * @return {Boolean}\n                 */\n                isImage: function() {\n                    return this.element.hasClass(IMAGE_TYPE_CLASS);\n                },\n\n                /**\n                 * Sets the `href` of the embed is URI to the embed content or\n                 * location. (ezcontent://32 for instance).\n                 *\n                 * @method setHref\n                 * @param {String} href\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setHref: function(href) {\n                    this.element.data('href', href);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the `href`of the embed.\n                 *\n                 * @method getHref\n                 * @return {String}\n                 */\n                getHref: function() {\n                    return this.element.data('href');\n                },\n\n                /**\n                 * Sets the widget content. It makes sure the config element is\n                 * not overwritten.\n                 *\n                 * @method setWidgetContent\n                 * @param {String|CKEDITOR.dom.node} content\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setWidgetContent: function(content) {\n                    let element = this.element.getFirst(),\n                        next;\n\n                    while (element) {\n                        next = element.getNext();\n                        if (!element.data || !element.data('ezelement')) {\n                            element.remove();\n                        }\n                        element = next;\n                    }\n\n                    if (content instanceof CKEDITOR.dom.node) {\n                        this.element.append(content);\n                    } else {\n                        this.element.appendText(content);\n                    }\n\n                    return this;\n                },\n\n                /**\n                 * Moves the widget after the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveAfter: function(element) {\n                    this.wrapper.insertAfter(element);\n                    this.fireEditorInteraction('moveAfter');\n                },\n\n                /**\n                 * Moves the widget before the given element. It also fires the\n                 * `editorInteraction` event so that the UI can respond to that\n                 * change.\n                 *\n                 * @method moveAfter\n                 * @param {CKEDITOR.dom.element} element\n                 */\n                moveBefore: function(element) {\n                    this.wrapper.insertBefore(element);\n                    this.fireEditorInteraction('moveBefore');\n                },\n\n                /**\n                 * Sets a config value under the `key` for the embed.\n                 *\n                 * @method setConfig\n                 * @param {String} key\n                 * @param {String} value\n                 * @return {CKEDITOR.plugins.widget}\n                 */\n                setConfig: function(key, value) {\n                    let valueElement = this.getValueElement(key);\n\n                    if (!valueElement) {\n                        valueElement = new CKEDITOR.dom.element('span');\n                        valueElement.data('ezelement', 'ezvalue');\n                        valueElement.data('ezvalue-key', key);\n                        this.getEzConfigElement().append(valueElement);\n                    }\n\n                    valueElement.setText(value);\n\n                    return this;\n                },\n\n                /**\n                 * Returns the config value for the `key` or undefined if the\n                 * config key is not found.\n                 *\n                 * @method getConfig\n                 * @return {String}\n                 */\n                getConfig: function(key) {\n                    const valueElement = this.getValueElement(key);\n\n                    return valueElement ? valueElement.getText() : undefined;\n                },\n\n                /**\n                 * Returns the Element holding the config under `key`\n                 *\n                 * @method getValueElement\n                 * @param {String} key\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getValueElement: function(key) {\n                    return this.element.findOne('[data-ezelement=\"ezvalue\"][data-ezvalue-key=\"' + key + '\"]');\n                },\n\n                /**\n                 * Returns the element used as a container the config values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzConfigElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzConfigElement: function() {\n                    let config = this.element.findOne('[data-ezelement=\"ezconfig\"]');\n\n                    if (!config) {\n                        config = new CKEDITOR.dom.element('span');\n                        config.data('ezelement', 'ezconfig');\n                        this.element.append(config, true);\n                    }\n\n                    return config;\n                },\n\n                /**\n                 * Returns the element used as a container the link values. if\n                 * it does not exist, it is created.\n                 *\n                 * @method getEzLinkElement\n                 * @return {CKEDITOR.dom.element}\n                 */\n                getEzLinkElement: function() {\n                    let link = this.element.findOne('[data-ezelement=\"ezlink\"]');\n\n                    if (!link) {\n                        link = new CKEDITOR.dom.element('a');\n                        link.$.innerHTML = ' ';\n                        link.setAttribute('data-ezelement', 'ezlink');\n                        link.setAttribute('data-ez-temporary-link', true);\n                        this.element.append(link);\n                    }\n\n                    return link;\n                },\n\n                /**\n                 * Gets the link attribute\n                 *\n                 * @method getEzLinkAttribute\n                 * @param {String} attribute\n                 * @return {String}\n                 */\n                getEzLinkAttribute: function(attribute) {\n                    const link = this.getEzLinkElement();\n\n                    return link.getAttribute(attribute);\n                },\n\n                /**\n                 * Sets the link attribute\n                 *\n                 * @method getEzLinkAttribute\n                 * @param {String} attribute\n                 * @param {String} value\n                 */\n                setEzLinkAttribute: function(attribute, value) {\n                    const link = this.getEzLinkElement();\n\n                    link.setAttribute(attribute, value);\n                },\n\n                /**\n                 * Removes the link attribute\n                 *\n                 * @method removeEzLinkAttribute\n                 * @param {String} attribute\n                 */\n                removeEzLinkAttribute: function(attribute) {\n                    const link = this.getEzLinkElement();\n\n                    link.removeAttribute(attribute);\n                },\n\n                /**\n                 * Sets the link edit state\n                 *\n                 * @method setLinkEditState\n                 */\n                setLinkEditState: function() {\n                    this.element.setAttribute(EDIT_LINK_STATE_ATTR, true);\n                },\n\n                /**\n                 * Removes the link edit state\n                 *\n                 * @method removeLinkEditState\n                 */\n                removeLinkEditState: function() {\n                    this.element.removeAttribute(EDIT_LINK_STATE_ATTR);\n                },\n\n                /**\n                 * Checks if widget is in link edit state\n                 *\n                 * @method isEditingLink\n                 * @return {Boolean}\n                 */\n                isEditingLink: function() {\n                    return this.element.hasAttribute(EDIT_LINK_STATE_ATTR);\n                },\n\n                /**\n                 * Fires the editorInteraction event so that AlloyEditor editor\n                 * UI remains visible and is updated. This method also computes\n                 * `selectionData.region` and the `pageX` and `pageY` properties\n                 * so that the add toolbar is correctly positioned on the\n                 * widget.\n                 *\n                 * @method fireEditorInteraction\n                 * @param {Object|String} evt this initial event info object or\n                 * the event name for which the `editorInteraction` is fired.\n                 */\n                fireEditorInteraction: function(evt) {\n                    const wrapperRegion = this.getWrapperRegion();\n                    const name = evt.name || evt;\n                    const event = {\n                        editor: editor,\n                        target: this.element.$,\n                        name: 'widget' + name,\n                        pageX: wrapperRegion.left,\n                        pageY: wrapperRegion.top + wrapperRegion.height,\n                    };\n\n                    editor.focus();\n                    this.focus();\n\n                    editor.fire('editorInteraction', {\n                        nativeEvent: event,\n                        selectionData: {\n                            element: this.element,\n                            region: wrapperRegion,\n                        },\n                    });\n                },\n\n                /**\n                 * Returns the wrapper element region.\n                 *\n                 * @method getWrapperRegion\n                 * @private\n                 * @return {Object}\n                 */\n                getWrapperRegion: function() {\n                    const scroll = this.wrapper.getWindow().getScrollPosition();\n                    const region = this.wrapper.getClientRect();\n\n                    region.top += scroll.y;\n                    region.bottom += scroll.y;\n                    region.left += scroll.x;\n                    region.right += scroll.x;\n                    region.direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;\n\n                    return region;\n                },\n            });\n        },\n    });\n})(window);\n\n\n\n// WEBPACK FOOTER //\n// ./src/bundle/Resources/public/js/alloyeditor/src/plugins/ez-embed.js"],"sourceRoot":""}